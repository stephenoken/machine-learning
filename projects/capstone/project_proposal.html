<h1 id="machine-learning-engineer-nanodegree">Machine Learning Engineer Nanodegree</h1>
<h2 id="capstone-proposal">Capstone Proposal</h2>
<p>Stephen O’Kennedy<br />
25 April, 2018</p>
<h2 id="proposal-identify-and-classify-toxic-online-comments">Proposal: Identify and classify toxic online comments</h2>
<h3 id="domain-background">Domain Background</h3>
<p>Since it’s inception the internet has allowed people from most parts of the world to freely communicate, debate, and collaborate with each other over a wide range of topics and projects. Platforms like Github, Hackernews, Twitter, Wikipedia, etc. form the foundations for which these interactions can take place. Many of these communities have standards and rules in place to facilitate conversations, and to prevent these communities from being hijacked, or destroyed by toxic behaviour. It is becoming increasingly harder to regulate and enforce these standards. In fact Facebook are currently hiring more and more moderators to sift through questionable content [1].</p>
<p><a href="https://conversationai.github.io/">Conversation AI</a> are working to provide tools to help improve online conversation[2][2]. One area that they’re focusing on is the study of negative online behaviours, like toxic comments[2][2]. As their Kaggle page states, the current models in use for detecting toxic comments still make errors, and they don’t allow users to be able to identify the types of toxicity they’re interested in finding. For example some platforms may be fine with comments that contain profanities.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a dataset that contains a large number of Wikipedia comments which have been labelled by human raters for toxic behaviour. We want to create a model that predicts the probability of different types of toxicity for each comment.</p>
<h3 id="datasets-and-inputs">Datasets and Inputs</h3>
<p>We are provided with a dataset in csv format where we have the following columns: <code>id</code> <code>comment_text</code> : [String] <code>toxic</code> : int <code>severe_toxic</code> : int <code>obscene</code> : int <code>threat</code> : int <code>insult</code> : int <code>identity_hate</code> : int</p>
<p>The <code>comment_text</code> column is comment that we want to feed into our classifier, and the outputs will be will be a vector containing the probabilities of the comment being one of the <code>toxic</code>, <code>obscene</code>, etc. The training data set can be found here [3].</p>
<h3 id="solution-statement">Solution Statement</h3>
<p>The solution will involved the development of deep learning algorithm that uses Keras with TensorFlow being used as the backend. Our aim is to use a multi-class CNN to process the content of the comments and out put a ROC AUC score [4][4]. Finally, predictions will be made on the test data set and will be evaluated on Kaggle.</p>
<h3 id="benchmark-model">Benchmark Model</h3>
<p>The benchmark score we’ll use to compare our model against will be <code>0.982900</code>. This score was is in the 50th percentile of the public leaderboards[5][5], and was calculated using ROC AUC metric [4][4].</p>
<h3 id="evaluation-metrics">Evaluation Metrics</h3>
<p>Submissions are evaluated by using the ROC AUC metric. Each comment in the test data set will need to be labeled with the predictions for each type of toxicity appearing in each comment, and will need to be submitted to Kaggle.</p>
<p>ROC is the receiver operating characteristic curve. It is a graphical plot that displays the discrimination threshold of a binary classier, which is what we’ll need to build. Our threshold (<span class="math inline"><em>T</em></span>), which is used to classify a datapoint as either positive or negative, is by default set <span class="math inline">0.5</span>. We take the true positive rate (<span class="math inline"><em>T</em><em>P</em><em>R</em></span>) and false positive rate (<span class="math inline"><em>F</em><em>P</em><em>R</em></span>) for all scores and plot a curve. Calculating the AUC (area under the curve) will reduce the curve down to a single value, <span class="math inline">1 ≥ <em>A</em> &lt; 0</span>. Where <span class="math inline"><em>A</em></span> is the AUC. If <span class="math inline"><em>A</em></span> is close to <span class="math inline">1.0</span> we’ve got a perfect classifier, if However it is <span class="math inline">0.5</span> of lower than our classifier is doing little more than guessing. [6]</p>
<p>The formula is:</p>
<p><br /><span class="math display"><em>A</em> = ∫<sub>∞</sub><sup> − ∞</sup><em>T</em><em>P</em><em>R</em>(<em>T</em>)<em>F</em><em>P</em><em>R</em>′(<em>T</em>)<em>d</em><em>T</em> = ∫<sub> − ∞</sub><sup>∞</sup>∫<sub>∞</sub><sup> − ∞</sup><em>I</em>(<em>T</em>′ &gt; <em>T</em>)<em>f</em><sub>1</sub>(<em>T</em>′)<em>f</em><sub>0</sub>(<em>T</em>)<em>d</em><em>T</em>′<em>d</em><em>T</em> = <em>P</em>(<em>X</em><sub>1</sub> &gt; <em>X</em><sub>0</sub>)</span><br /></p>
<h3 id="project-design">Project Design</h3>
<p>Use CNN because we can feed matrices of text or maybe MLP</p>
